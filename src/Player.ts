import { OscObj } from "./types"
import { SpearPartial } from "./types/SpearPartial"

export default class Player {

  audioContext: AudioContext
  partialData: SpearPartial[] = []
  playing = false
  offset = 0
  oscillators: OscObj[] = []
  register: (() => void) | null
  valuesSetForFirstPartial = []
  waveform: OscillatorType = 'sine'

  constructor (register: (() => void) | null = null) {
    this.register = register

    // Start audio context.
    // const audioCtx = window.AudioContext || window.webkitAudioContext
    const audioCtx = window.AudioContext
    this.audioContext = new audioCtx({
      latencyHint: 0,
      // sampleRate: 31000,
    })
    // This is necessary to make audio playback work on iOS.
    this.audioContext.resume()
  }

  setup (partialData: SpearPartial[], startInSec: number, now: number, outputLatency: number) {
    this.partialData = partialData
    const timeToAddToStart = now + outputLatency + startInSec

    // Initialize oscillators
    for (const partial of partialData) {
      this.oscillators.push(this.createOscillatorAndGainNodes(partial, timeToAddToStart))
    }
    this.playing = true;
  }

  /** 
  * Creates OscillatorNode and GainNode for the partial, and sets all needed values on the nodes
  * @param {SpearPartial} partial - The partial generated by SPEAR 
  * @param {number} timeToAddToStart - The time to add to the starting time. Originally
  * intended to give the devices more time for setting all values before playback starts.
  * @return {OscObj} Returns an object containing the created nodes.
  */
  createOscillatorAndGainNodes (partial: SpearPartial, timeToAddToStart: number): OscObj {
    if (!this.audioContext) {
      throw new Error('Player.audioContext not set.')
    }

    const oscNode = this.audioContext.createOscillator()
    oscNode.type = this.waveform
    oscNode.frequency.value = 0
    oscNode.start(Number(partial.startTime) + timeToAddToStart)
    oscNode.stop(Number(partial.endTime) + timeToAddToStart)
    oscNode.onended = () => this.handleOscillatorEndedEvent(gainNode)

    const gainNode = this.audioContext.createGain()
    gainNode.gain.value = 0

    // Connect oscNode to gainNode and gainNode to destination
    oscNode.connect(gainNode);
    gainNode.connect(this.audioContext.destination)

    for (const breakpoint of partial.breakpoints) {
      const time = Number(breakpoint.time) + timeToAddToStart
      oscNode.frequency.setValueAtTime(breakpoint.freq, time)
      gainNode.gain.setValueAtTime(breakpoint.amp, time)
    }

    return {
      oscNode,
      gainNode,
    }
  }

  stop () {
    if (!this.oscillators) return
    for (const oscObj of this.oscillators) {
      // oscObj.oscNode.stop()
      oscObj.oscNode.onended = null
      oscObj.gainNode.disconnect()
    }
    this.reset()
  }

  handleOscillatorEndedEvent (gainNode: GainNode): void {
    const oscIndex = this.oscillators?.findIndex(oscObj => oscObj.gainNode = gainNode)
    gainNode.disconnect()
    if (this.oscillators && oscIndex >= 0) {
      this.oscillators.splice(oscIndex, 1);
    }
    if (!this.oscillators.length) {
      this.reset()
    }
  }

  /** 
  * Sets this.oscillators = [] and this.playing = false.
  * If register is set (meaning we are not playing locally), re-register.
  */
  reset (): void {
    this.oscillators = []
    this.playing = false
    if (this.register) {
      this.register()
    }
  }

  playOneShot (now: number): void {
    const oscNode = this.audioContext.createOscillator()
    const gainNode = this.audioContext.createGain()

    oscNode.frequency.value = 400
    oscNode.type = 'sawtooth'
    gainNode.gain.value = 0.1

    oscNode.connect(gainNode);
    gainNode.connect(this.audioContext.destination)

    oscNode.start(now)
    oscNode.stop(now + 0.02)
  }
}
